---
layout:     post
title:      Анализ взаимосвязи навыков для профессии программиста с помощью графов в R 
date:       2017-05-07 15:31:19
summary:    Данное исследование помогает с помощью методов анализа данных ответить на вопрос как взаимосвязаны навыки, какие есть специализации, какие навыки более популярны, а какие навыки следует изучить следующим.
categories: research
---

Интересно, но такая область как профессиональное развитие остается немного в стороне от шума из-за data science. Стартапы в сфере HRtech только начинают наращивать обороты и увеличивать свою долю, замещая традиционный подход в сфере работы с профессионалами. 

Сфера HRtech очень разнообразна и включает в себя автоматизацию найма сотрудников, развитие и коачинг, автоматизацию внутренних HR процедур, отслеживание рыночных зарплат, трекинг кандидатов, сотрудников и многое другое. Данное исследование помогает с помощью методов анализа данных ответить на вопрос как взаимосвязаны навыки, какие есть специализации, какие навыки более популярны, а какие навыки следует изучить следующим.




### Постановка задачи и входные данные

Изначально не хотелось разделять навыки по какой-то известной классификации. Например, через среднюю зарплату можно было выделить «дорогие» и «дешевые» навыки. Нам хотелось выделить «специализации» основываясь на математике и статистике. Поэтому в данном исследовании встала задача unsepervised learning для объединения навыков в группы. И первой профессией мы выбрали программиста.
 
Для анализа мы брали данные с портала [Работа в России](http://trudvsem.ru) доступные на [data.gov.ru](http://data.gov.ru/opendata/7710538364-vacansii). Здесь представлены все вакансии, доступные на портале с описанием, зарплатой, регионом и прочими деталями. Далее мы распарсили описания и выделили из них навыки. Это отдельное исследование и этой статьей не покрывается. Однако уже размеченные данные можно также взять с API [hh.ru](http://hh.ru). 
 
Таким образом исходные данные представлены матрицей со значениями 0/1, в которой `X` - навыки, а объекты - вакансии. Всего 164 признака и 841 объект.




### Подбор метода поиска групп навыков

При выборе метода я основывался на предположении, что одна вакансия может иметь несколько специализаций. А также исходил из допущения, что конкретный навык может относиться только к одной специализации. Раскрою карты, это допущение требовалось для работы алгоритмов, использующих результаты данного исследования.

Решая задачу в лоб, можно предположить, что если одна группа навыков встречается у одной группы вакансий, а другая группа навыков - у другой группы вакансий, то это группа навыков и есть специализация. И можно разделить навыки с помощью метрических методов (k-means и модификации). Но проблема как раз была в том что, одна вакансия могла иметь несколько специализаций и в итоге, как бы я не крутил алгоритм, он относил 90% навыков к одному кластеру и еще с десяток кластеров по 1-2 навыка. Поразмыслив, решил переписать k-means под задачу и вместо классического евклидово расстояния выбрал меру смежности навыков, то есть частоту встречаемости двух навыков:

```r
library(data.table)
grid<-as.data.table(expand.grid(skill_1=names(skills_clust),skill_2=names(skills_clust)))
grid<-grid[grid$skill_1 != grid$skill_2,]
for (i in c(1:nrow(grid))){
  grid$value[i]<-sum(skills_clust[,grid$skill_1[i]]*skills_clust[,grid$skill_2[i]])
}
```

Но, к счастью, вовремя пришла идея представить задачу как задачу поиска сообществ в графах. И настало время вспоминать теорию графов благополучно забытую после второго курса университета. 




### Построение и анализ графа навыков

Для того чтобы построить граф мы воспользуемся пакетом `igraph` (такой же есть и в python) и прежде всего мы создадим матрицу смежности из таблицы, которую мы начали считать для k-means (`grid`). Затем отнормируем смежность навыков в диапазоне от 0 до 1: 

```r
grid_clean<-grid[grid$value>1,] # пары навыков встречающиеся <=1 раза исключаются
grid_cast<-dcast(grid_clean,skill_1~skill_2)
grid_cast[,skill_1:=NULL]
grid_cast_norm<-grid_cast/colSums(grid_cast,na.rm=T)
grid_cast_norm[is.na(grid_cast_norm)]<-0
grid_cast_norm<-as.matrix(grid_cast_norm) 
grid_cast_norm[grid_cast_norm<=0.02] <-0 # пары навыков встречающиеся <=2% исключаются
```

Смежность навыка `i` и навыка `j` мы нормируем как долю от общей встречаемости навыка `i`. Изначально я нормировал матрицу как долю от максимальной встречаемости всех навыков, но затем перешел к этой формуле. Идея в том, что, к примеру, навык `i` встречается с навыком `j` 10 раз, и больше ни с каким другим навыком не встречается. Можно предположить, что такая связь будет более весомой (например 100%), чем если бы мы смотрели эту встречаемость от максимальной в данной матрице (например, 100 - 10%).

Также для очистки матрицы смежности от случайных связей, я убрал пары встречающиеся меньше 2-х раз или 2% от общей встречаемости данного навыка. К сожалению, это сократило набор навыков с 164 до 87, однако сделала сегменты более логичными и понятными.

Затем мы создаем ненаправленный взвешенный граф из матрицы смежности:

```r
library(igraph)
skills_graph<-graph_from_adjacency_matrix(grid_cast_norm, mode = "undirected",weighted=T)
plot(skills_graph, vertex.size=5)
```

![skills_no_cluster](https://raw.githubusercontent.com/alexakimenko/alexakimenko.github.io/master/images/skills.001.png "skills no cluster")

`igraph` нам также позволяет посчитать основы статистики по вершинам:

```r
closeness(skills_graph) # Центральность вершины на основании расстояния до других вершин
betweenness(skills_graph) # Количество самых коротких путей, проходящих через вершину
degree(skills_graph) # Количество связанных вершин с данной вершиной
```

Затем можем вывести лист смежности для каждого навыка. Этот лист в дальнейшем может стать основой рекомендательной системы для выбора новых навыков:

```r
get.adjlist(skills_graph)
```




### Выделение сообществ методом Multilevel

На тему поиска сообществ в графах мне попалась отличная [работа Славнова Константина](http://www.machinelearning.ru/wiki/images/6/60/2015_417_SlavnovKA.pdf). Эта статья рассладывает по полочкам основные метрики качества выделения сообществ, методы выделения сообществ и аггрегирования результатов работы этих методов.

Когда истинное разбиение на сообщества не известно для оценки качества используется значение функционала модулярности (modularity). Это самая популярная и общепризнанная мера качества для данной задачи. Функционал был предложен Ньюманом и Гирваном в ходе разработки алгоритма кластеризации вершин графа.

Для оптимизации данного функционала чаще всего используется алгоритм Multilevel, предложенный в [статье](https://arxiv.org/abs/0803.0476). Во-первых, из-за хорошего качества оптимизации, во-вторых, из-за скорости (в данной задаче это не требовалось, но все же), в-третьих, алгоритм достаточно интуитивно понятен.

На наших данных этот алгоритм также показал один из лучших результатов:

| |Algorithm|Modularity|Number of communities|
|---|---|---|---|
|1|Betweenness|0.223|6|
|2|Fastgreedy|0.314|8
|3|Multilevel|0.331|8|
|4|LabelPropogation|0.257|15|
|5|Walktrap|0.316|10|
|6|Infomap|0.315|13|
|7|Eigenvector|0.348|8|

В пакте `igraph` этот алгоритм реализуется функцией `cluster_louvain()`:

```r
fit_cluster<-cluster_louvain(skills_graph)
V(skills_graph)$group <- fit_cluster$membership
```




### Результаты


![skills_cluster](https://raw.githubusercontent.com/alexakimenko/alexakimenko.github.io/master/images/skills.003.jpeg "skills cluster")

Как мы видим, удалось выявить 8 специализаций (названия даны субъективно автором статьи):

* **Обслуживание серверов и сетей** - включает знание Microsoft Hyper-V, VMware vSphere, ремонт и отстройка техники. Требуется также знание английского языка;
* **Разработчик промышленных систем/контроллеров** - тут целый набор от C/C++ до Java включая Assembler и SCADA;
* **Разработчик ERP-систем (1С, SAP)** - здесь помимо 1C, SAP, ABAP требуется еще знание основ бухгалтерcкого, управленческого учета и навыки техподдержки пользователей;
* **Программирование станков** - в этой специализации требуются навыки составление программ для станков с ЧПУ, программирование на Unigraphics NX и знание систем управления станков;
* **Общие навыки программирования** - включает знание ГОСТ, структурного программирования, навыки написания ТЗ и почему-то китайского языка (наверное кому-то очень нужен);
* **Разработчик под Microsoft со знанием БД** - C#, .NET Framework, MS SQL Server, FoxPro, Опыт работы с чужим кодом/рефакторинг и прочее;
* **Веб-разработчик** - JavaScript, HTML, СSS, PLPG/SQL (PostgreSQL), jQuery, PHP  и пр. Интересно, что именно в этой специализации чаще всего требуются такие навыки как знание концепции ООП, Agile и владение системами контроля версий;
* **Разработчик мобильных приложений** - знание Swift, опыт разработки Android/iOS приложений;

Специализации довольно тесно взаимосвязаны. Это объясняется нашим основным предположением, что одна вакансия может иметь несколько специализаций. Так, например, в специализации "Разработчик мобильных приложений" требуется "Знание сетевых протоколов" (71), которое в свою очередь взаимосвязано с "Администрирование локальных сетей" (32) из специализации "Обслуживание серверов и сетей". 

Также следует понимать, что источник данных это портал "Работа в России", выборка вакансий на котором отличается от hh.ru или superjob.ru - вакансии смещены в сторону вакансий с более низкой квалификацией. Плюс выборка ограничена 841 вакансией (из них только 585 имели отметки о каких-либо навыках), из-за этого большое количество навыков не было проанализировано и не попало в специализации. 

Однако в целом предложенный алгоритм дает достаточно логичные результаты и позволяет в автоматическом режиме для профессий, которые можно квантифицировать (естественно навыки топ менеджера будет невозможно выделить в специализации), ответить на вопросы как взаимосвязаны навыки, какие есть специализации, какие навыки более популярны, а какие навыки следует изучить следующим. 

Всем кто дочитал до конца - бонус. [По ссылке](https://alexakimenko.shinyapps.io/skills_clusters/) можно поиграться с интерактивной визуалицией графа и скачать итоговую таблицу с результатами исследовани.


<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//https-alexakimenko-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
